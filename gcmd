#!/bin/bash

# gcmd - Natural Language Shell Command Executor
# Converts natural language to shell commands using OpenAI API

set -e

VERSION="1.0.0"
CONFIG_DIR="${HOME}/.config/gcmd"
CONFIG_FILE="${CONFIG_DIR}/config"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Print colored output
print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${CYAN}$1${NC}"
}

print_command() {
    echo -e "${YELLOW}${BOLD}$1${NC}"
}

# Show usage
show_usage() {
    echo -e "${BOLD}gcmd${NC} - Natural Language Shell Command Executor"
    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  gcmd <natural language description>"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  gcmd list all files in current directory"
    echo "  gcmd find all python files modified in last 7 days"
    echo "  gcmd show disk usage sorted by size"
    echo "  gcmd create a tar archive of the src folder"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  -h, --help     Show this help message"
    echo "  -v, --version  Show version"
    echo ""
    echo -e "${BOLD}Environment:${NC}"
    echo "  OPENAI_API_KEY  Your OpenAI API key (required)"
    echo "  GCMD_MODEL      OpenAI model to use (default: gpt-4o-mini)"
    echo ""
    echo -e "${BOLD}Setup:${NC}"
    echo "  export OPENAI_API_KEY='your-api-key'"
}

# Show version
show_version() {
    echo "gcmd version ${VERSION}"
}

# Check for required dependencies
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        echo "Please install curl and try again."
        exit 1
    fi
}

# Check for API key
check_api_key() {
    if [ -z "${OPENAI_API_KEY}" ]; then
        print_error "OPENAI_API_KEY environment variable is not set."
        echo ""
        echo "Please set your OpenAI API key:"
        echo "  export OPENAI_API_KEY='your-api-key'"
        echo ""
        echo "Add it to your ~/.bashrc or ~/.zshrc to make it permanent."
        exit 1
    fi
}

# Get the model to use
get_model() {
    if [ -n "${GCMD_MODEL}" ]; then
        echo "${GCMD_MODEL}"
    else
        echo "gpt-4o-mini"
    fi
}

# Escape string for JSON
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    echo "$str"
}

# Build the system prompt
build_system_prompt() {
    local os_info
    local shell_info
    local cwd

    os_info=$(uname -s)
    shell_info=$(basename "${SHELL}")
    cwd=$(pwd)

    cat << EOF
You are a shell command generator. Convert natural language instructions into executable shell commands.

Rules:
1. Return ONLY the shell command, nothing else
2. No explanations, no markdown, no code blocks
3. No backticks or quotes around the command
4. Commands should be safe and non-destructive when possible
5. Use common Unix/Linux commands that work on most systems

Context:
- Operating System: ${os_info}
- Shell: ${shell_info}
- Current Directory: ${cwd}

If the request is unclear or potentially dangerous, still provide the most reasonable command but the user will review before execution.
EOF
}

# Call OpenAI API
call_openai() {
    local user_prompt="$1"
    local model
    local system_prompt
    local response
    local command
    local error_message

    model=$(get_model)
    system_prompt=$(build_system_prompt)

    # Escape strings for JSON
    local escaped_system
    local escaped_user
    escaped_system=$(json_escape "$system_prompt")
    escaped_user=$(json_escape "$user_prompt")

    # Build the request payload
    local payload
    payload=$(cat << EOF
{
    "model": "${model}",
    "messages": [
        {"role": "system", "content": "${escaped_system}"},
        {"role": "user", "content": "${escaped_user}"}
    ],
    "temperature": 0.1,
    "max_tokens": 500
}
EOF
)

    # Make the API call
    response=$(curl -s -w "\n%{http_code}" \
        -X POST "https://api.openai.com/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${OPENAI_API_KEY}" \
        -d "$payload" 2>&1)

    # Extract HTTP status code (last line)
    local http_code
    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    # Check for HTTP errors
    if [ "$http_code" != "200" ]; then
        error_message=$(echo "$response" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/"message"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
        if [ -n "$error_message" ]; then
            print_error "API Error: $error_message"
        else
            print_error "API request failed with HTTP status $http_code"
        fi
        exit 1
    fi

    # Extract the command from the response
    # Try using python if available for reliable JSON parsing
    if command -v python3 &> /dev/null; then
        command=$(echo "$response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data['choices'][0]['message']['content'].strip())
except:
    sys.exit(1)
" 2>/dev/null)
    elif command -v python &> /dev/null; then
        command=$(echo "$response" | python -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data['choices'][0]['message']['content'].strip())
except:
    sys.exit(1)
" 2>/dev/null)
    else
        # Fallback: use grep/sed for parsing (less reliable)
        command=$(echo "$response" | grep -o '"content"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/"content"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    if [ -z "$command" ]; then
        print_error "Failed to parse command from API response"
        exit 1
    fi

    # Clean up command (remove any markdown artifacts)
    command=$(echo "$command" | sed 's/^```[a-z]*$//' | sed 's/^```$//' | sed '/^$/d' | head -1)

    echo "$command"
}

# Main function
main() {
    # Handle options
    case "${1:-}" in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        "")
            show_usage
            exit 1
            ;;
    esac

    # Check dependencies and API key
    check_dependencies
    check_api_key

    # Get the natural language input
    local user_input="$*"

    print_info "Generating command..."
    echo ""

    # Get the command from OpenAI
    local generated_command
    generated_command=$(call_openai "$user_input")

    if [ -z "$generated_command" ]; then
        print_error "No command generated"
        exit 1
    fi

    # Display the generated command
    echo -e "${BLUE}Command:${NC}"
    print_command "  $generated_command"
    echo ""

    # Ask for confirmation
    echo -n -e "${BOLD}Execute this command? (Y/n):${NC} "
    read -r confirmation

    # Check user response
    case "$confirmation" in
        n|N|no|No|NO)
            echo ""
            print_info "Command aborted."
            exit 0
            ;;
        *)
            # Execute the command (y, Y, Enter, or any other input)
            echo ""
            echo -e "${BLUE}Output:${NC}"
            echo "----------------------------------------"
            eval "$generated_command"
            local exit_code=$?
            echo "----------------------------------------"
            if [ $exit_code -eq 0 ]; then
                print_success "Command completed successfully."
            else
                print_error "Command exited with code $exit_code"
            fi
            exit $exit_code
            ;;
    esac
}

# Run main
main "$@"
